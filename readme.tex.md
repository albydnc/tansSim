# TANS 2019-2020 Final Project
### Description
This program is a basic implementation of simulation and recontruction of particles colliding events (proton-proton collision).\
The collisions are generated in a region called _collision diamond_ centered in the origin of a cartesian plane, where **z** is the beampipe direction.\
The result of a vertex detector is to determine the coordinates of the collision (_primary vertex_).\
In this project only the *z* coordinate is being reconstructed.

### Experimental Setup
The vertex detector is built of two cylindrical silicon pixel detectors, coaxial with the beampipe.\
While often the interaction region is in a magnetic field, it is supposed that the field intensity and the distance from vertex to detectors is small enough to assume that the trajectories of charged particles are rectilinear (_locally and with high momentum_).\
The vertex specification are:
- The standard deviation in _z_ is $\sigma_{z} = 53 mm$.
- The standard deviation in _x_ and _y_ is $\sigma_{x}=\sigma_{y} = 0.1 mm$.

The beampipe is made of Berilium and has a radius of 30 mm and a thickness of 0.8 mm.\
The first pixel detector has a radius of 40 mm and a thickness of 0.2 mm.\
The second pixel detector has a radius of 70 mm and a thickness of 0.2 mm.\
Each one of the detectors 270 mm long.\
Hit points' smearing is based on a gaussian distribution with $120 \mu m$ in *z* and $30 \mu m$ in $r\phi$.\
Multiple scattering is simulated in the beampipe and silicon layers.

### Simulation
Collision vertexes are generated with a normal distribution and particles follow the pseudorapidity and angle distribution from a given kinematic file. Multiplicity can be generated from different distributions (_default:_ gaussian).\
The vertex coordinates and multiplicity generate by `generateVertex(double * ptc)` are saved in a double's array `ptc[4]`.\
The coordinates are then passed to the `generateParticles(double *ptc, TClonesArray *particles, const uint8_t distType)` where particles are generated by the defined distributions, then their coordinates are saved in a TClonesArray.\
Particles' array is passed to `intersect(double *ptc, TClonesArray *particles, TClonesArray *Hits, double width, double radius, double z_sm, double rho_sm, int randomNoise)` where intersection with the detector layer is calculated; the method accept as inputs witdh, radius, z smearing, rho smearing and can also generate a number of random coordinates simulating noise and low energy particles.\
Paricles which don't intersect are dropped to speed up computation. The result is a TClonesArray containing hits' coordinates expressed in cylindrical coordinates. The same is repeated for the second detector layer.\
If multiple scattering is enabled, before any intersect, the method `multipleScattering(TClonesArray *particles, double rmsTh)` is called. This method modifies the particles' array by applying the rotation matrix to the scattering vector.\
The simulation then fills a file called `simulation.root` with vertexes' and hits' arrays.

#### Interaction with detector layers
`intersect(double *ptc, TClonesArray *particles, TClonesArray *Hits, double width, double radius, double z_sm, double rho_sm, int randomNoise)` is the intersection method.\
Given a primary vertex and a particles' array, a basic linear interpolation is computed to find the interaction point on the detector. The interaction point is then smeared by generating random values with a given mean and rms value. Detector noise can be generated specifying the number of random points, then the coordinates are generated following a normal distribution for z and $\phi$.

`multipleScattering(TClonesArray *particles, double rmsTh)` is the multiple scattering method.\
Given a particles' array and a rms angle value, a rotation matrix is built with the particles coordinates then a scattering vector is computed via random generation of $\theta$ and $\phi$ values. The two are multiplied and the result are the new particle's coordinates, which replace the originals in the array.

### Reconstruction
The recontruction part reads the events from the previous simulation file to reconstruct events' vertexes.

##### Tracklet Algorithm
A simple linear interpolation is done after a large angle filter. The results are then plotted and the mode value is returned.

##### Statistics generation
The reconstruction process will print the resulting statistics, giving the user histograms on:
+ Vertex resolution distribution
+ Resolution vs Z-axis span` multipleScattering(TClonesArray *particles, double rmsTh)`
+ Efficiency vs Multiplicity
+ Efficiency vs Z-axis span

### Simulation and Reconstruction Performance
**Testbench:**
+ Ubuntu 18.04.2 LTS
+ ROOT v6.19.0
+ Intel i7-6700HQ Laptop CPU
+ 16GB DDR4 RAM
+ 512GB NVMe SSD

Simulation of 1M events takes 80 seconds on average.
Reconstruction of 1M events takes 40 seconds on average.

Performance is greatly improved by using the C++ STL data classes over _TClonesArray_.
Simulation of 1M events is around 10 seconds average. **8x faster**.
As for now (ROOT v6.19.0), _TTree_ does not support `std::vector<std::array<double,2>>` so the development is not further going on.
I will keep track of ROOT new releases to see if it will be supported.
Post opened on the [ROOT forum](https://root-forum.cern.ch/t/adding-std-array-double-2-to-a-ttree-branch/37425).

*Written by Alberto Perro - 2019*
